import { NextRequest, NextResponse } from 'next/server'
import { getPayload } from 'payload'
import config from '@/payload.config'
import { OrderInput } from '@/types/api'
import { requireAdminOrManager } from '@/lib/auth'
import { withRateLimit, rateLimitConfigs } from '@/lib/rate-limit'
import { filterOrderData, getSecurityHeaders } from '@/lib/response-filter'

// Define PayloadError type for error narrowing
type PayloadError = Error & { status?: number }

// POST /api/orders - Create new order (public with rate limiting)
export const POST = withRateLimit(
  rateLimitConfigs.strict, // Strict rate limiting for order creation
  async (request: NextRequest) => {
    console.log('Processing order creation request')
    try {
      const orderData: OrderInput = await request.json()
      console.log('Received order data:', JSON.stringify(orderData, null, 2))

      // Validate required fields
      if (
        !orderData.customer?.fullName ||
        !orderData.customer?.email ||
        !orderData.customer?.phone
      ) {
        return NextResponse.json(
          { success: false, error: 'Customer information is required' },
          { status: 400, headers: getSecurityHeaders() },
        )
      }

      if (!orderData.items || orderData.items.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Order items are required' },
          { status: 400, headers: getSecurityHeaders() },
        )
      }

      const payload = await getPayload({ config })

      // Create or update customer first
      let _customer
      try {
        const existingCustomer = await payload.find({
          collection: 'customers',
          where: {
            email: { equals: orderData.customer.email },
          },
          limit: 1,
        })

        if (existingCustomer.docs.length > 0) {
          _customer = await payload.update({
            collection: 'customers',
            id: existingCustomer.docs[0].id,
            data: {
              name: orderData.customer.fullName,
              email: orderData.customer.email,
              primaryPhone: orderData.customer.phone,
              secondaryPhone: orderData.customer.secondaryPhone,
              addresses: orderData.customer.address
                ? [
                    {
                      type: 'home',
                      address: `${orderData.customer.address.street}, ${orderData.customer.address.city}, ${orderData.customer.address.postalCode}, ${orderData.customer.address.province}`,
                      isDefault: true,
                    },
                  ]
                : [],
              preferences: {
                communicationMethod: 'whatsapp',
                marketingOptIn: orderData.customer.marketingOptIn || false,
              },
              whatsapp: { isVerified: false },
              status: 'active',
              customerType: 'regular',
            },
          })
        } else {
          _customer = await payload.create({
            collection: 'customers',
            data: {
              name: orderData.customer.fullName,
              email: orderData.customer.email,
              primaryPhone: orderData.customer.phone,
              secondaryPhone: orderData.customer.secondaryPhone,
              addresses: orderData.customer.address
                ? [
                    {
                      type: 'home',
                      address: `${orderData.customer.address.street}, ${orderData.customer.address.city}, ${orderData.customer.address.postalCode}, ${orderData.customer.address.province}`,
                      isDefault: true,
                    },
                  ]
                : [],
              preferences: {
                communicationMethod: 'whatsapp',
                marketingOptIn: orderData.customer.marketingOptIn || false,
              },
              whatsapp: { isVerified: false },
              status: 'active',
              customerType: 'regular',
            },
          })
        }
      } catch (customerError) {
        console.error('Error creating/updating customer:', customerError)
        return NextResponse.json(
          { success: false, error: 'Failed to create customer' },
          { status: 500, headers: getSecurityHeaders() },
        )
      }

      // Create order
      try {
        console.log('Creating order with data:', JSON.stringify(orderData, null, 2))
        const order = await payload.create({
          collection: 'orders',
          data: {
            orderNumber: '', // Placeholder, will be auto-generated by hook
            customerName: orderData.customer.fullName,
            customerEmail: orderData.customer.email,
            customerPhone: orderData.customer.phone,
            customerSecondaryPhone: orderData.customer.secondaryPhone,
            deliveryAddress: `${orderData.customer.address.street}, ${orderData.customer.address.city}, ${orderData.customer.address.postalCode}, ${orderData.customer.address.province}`,
            specialInstructions: orderData.specialInstructions,
            orderItems: orderData.items.map((item) => ({
              productId: item.product.id || 'unknown',
              productName: item.product.title || item.product.name || 'Unknown Product',
              productSku: item.product.sku || 'unknown',
              unitPrice: item.variant?.price || item.price || 0,
              quantity: item.quantity,
              selectedSize: item.variant?.size || item.size,
              selectedColor: item.variant?.color || item.color,
              subtotal: (item.variant?.price || item.price || 0) * item.quantity,
            })),
            orderSubtotal: orderData.pricing.subtotal,
            shippingCost: orderData.pricing.shipping || 0,
            discount: 0,
            orderTotal: orderData.pricing.total,
            orderStatus: 'pending',
            paymentStatus: 'pending',
            paymentMethod: 'cod',
            orderSource: orderData.orderSource || 'website',
            whatsapp: {
              messageSent: false,
              messageTemplate: 'order-confirmation',
            },
          },
        })

        // Return limited order data (no sensitive info)
        const responseData = {
          orderNumber: order.orderNumber,
          id: order.id,
          status: order.orderStatus,
          total: order.orderTotal,
          currency: 'LKR',
          createdAt: order.createdAt,
        }

        return NextResponse.json(
          { success: true, data: responseData },
          { headers: getSecurityHeaders() },
        )
      } catch (orderError) {
        console.error('Error creating order:', orderError)

        let errorMessage = 'Failed to create order'
        let statusCode = 500

        if (orderError instanceof Error) {
          errorMessage = orderError.message

          // Check if it's a Payload validation error
          if ('status' in orderError && typeof (orderError as PayloadError).status === 'number') {
            statusCode = (orderError as PayloadError).status ?? 500
          }
        }

        return NextResponse.json(
          {
            success: false,
            error: errorMessage,
            ...(process.env.NODE_ENV === 'development' && {
              details: orderError instanceof Error ? orderError.stack : String(orderError),
            }),
          },
          { status: statusCode, headers: getSecurityHeaders() },
        )
      }
    } catch (error) {
      console.error('Orders API error:', error)
      return NextResponse.json(
        { success: false, error: 'Invalid request data' },
        { status: 400, headers: getSecurityHeaders() },
      )
    }
  },
)

// GET /api/orders - List orders (admin/manager only, with rate limiting)
export const GET = withRateLimit(
  rateLimitConfigs.moderate,
  requireAdminOrManager(async (request: NextRequest, auth) => {
    try {
      const { searchParams } = new URL(request.url)
      const page = parseInt(searchParams.get('page') || '1')
      const limit = parseInt(searchParams.get('limit') || '20')
      const status = searchParams.get('status')
      const customerEmail = searchParams.get('customerEmail')

      const payload = await getPayload({ config })

      // Build where conditions
      type OrderWhereConditions = {
        orderStatus?: { equals: string }
        customerEmail?: { equals: string }
      }

      const whereConditions: OrderWhereConditions = {}

      if (status) {
        whereConditions.orderStatus = { equals: status }
      }

      if (customerEmail && auth?.isAdmin) {
        whereConditions.customerEmail = { equals: customerEmail }
      }

      const result = await payload.find({
        collection: 'orders',
        where: whereConditions,
        page,
        limit: Math.min(limit, 100), // Limit max results
        sort: '-createdAt', // Newest first
      })

      // Filter sensitive data based on user permissions
      const filteredOrders = result.docs
        .map((order) => filterOrderData(order as unknown as Record<string, unknown>, auth!))
        .filter((order) => order !== null)

      return NextResponse.json(
        {
          success: true,
          data: filteredOrders,
          pagination: {
            page: result.page || 1,
            limit: result.limit,
            totalPages: result.totalPages,
            totalDocs: result.totalDocs,
            hasNextPage: result.hasNextPage,
            hasPrevPage: result.hasPrevPage,
          },
        },
        { headers: getSecurityHeaders() },
      )
    } catch (error) {
      console.error('Get orders error:', error)
      return NextResponse.json(
        { success: false, error: 'Failed to fetch orders' },
        { status: 500, headers: getSecurityHeaders() },
      )
    }
  }),
)
